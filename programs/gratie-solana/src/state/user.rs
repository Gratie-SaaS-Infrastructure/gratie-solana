use anchor_lang::prelude::*;

#[account]
#[derive(Default)]
pub struct User {
    pub company: Pubkey,

    pub owner: Pubkey,
    // TODO: ensure the user id is unique somehow
    // this is a uuid generated by the company and saved with the user in the database
    // when the user logs in he can receive this id via company api
    pub user_id: String,

    // the company (in frontend) creates a private key that's encrypted with the company_name, user_email and user_password (encrypted) and some other secret
    // this keypair should be derived from the company license pubkey
    // the problem here is that the company will have full access to that private key
    // so when the user claims his bucket a new private key should be encrypted with that users password
    // this way the user can decrypt his private key in the frontend and use it to sign transactions
    // this option is by default Some() but can be set to None if the user moves the bucket to his own wallet
    // the user should be incentivized to move the bucket to his own wallet
    // WARN: this is probably very unsafe!
    pub encrypted_private_key: Option<String>,

    // algorithm the company uses to encrypt their users passwords
    // this is used to decrypt the encrypted_private_key
    // the company should be able to change this
    // this is only needed the first time the user logs into gratie
    // cause after that the user can decrypt the private key with his email and password (plaintext)
    // these can be set to None after the user has logged in the first time
    // maybe put those in a burnable account?
    pub user_password_encryption_algorithm: Option<u8>,
    pub user_password_salt: Option<String>,

    pub claimed: bool,
    pub claimed_to_his_own_wallet: bool,

    pub bump: u8,
}

impl User {
    pub const LEN: usize = std::mem::size_of::<Self>() + 400;
}
