use crate::{
    error::MyError,
    state::{user::User, user_rewards_bucket::UserRewardsBucket},
};
use anchor_lang::prelude::*;
use anchor_spl::token;

pub fn claim_user_to_his_own_wallet_handler(
    ctx: Context<ClaimUserToHisOwnWallet>,
    new_public_key: Pubkey,
) -> Result<()> {
    if ctx.accounts.old_token_account.key() != ctx.accounts.user_rewards_bucket.token_account.key()
    {
        return Err(MyError::InvalidOldTokenAccount.into());
    }

    if !ctx.accounts.user.claimed {
        return Err(MyError::UserNotClaimedYet.into());
    }

    if ctx.accounts.user.claimed_to_his_own_wallet {
        return Err(MyError::UserAlreadyClaimedToHisOwnWallet.into());
    }

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.old_token_account.to_account_info(),
        to: ctx.accounts.new_token_account.to_account_info(),
        authority: ctx.accounts.claimer.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    token::transfer(cpi_ctx, ctx.accounts.user_rewards_bucket.balance)?;

    ctx.accounts.user.owner = new_public_key;
    ctx.accounts.user.user_password_encryption_algorithm = None;
    ctx.accounts.user.user_password_salt = None;
    ctx.accounts.user.encrypted_private_key = None;

    ctx.accounts.user.claimed_to_his_own_wallet = true;

    Ok(())
}

#[derive(Accounts)]
pub struct ClaimUserToHisOwnWallet<'info> {
    #[account(mut, address = user.owner)]
    pub claimer: Signer<'info>,

    #[account(mut)]
    pub user: Account<'info, User>,
    #[account(mut, seeds = [b"user_rewards_bucket", user.key().as_ref()], bump = user_rewards_bucket.bump)]
    pub user_rewards_bucket: Account<'info, UserRewardsBucket>,

    // token account of the user that was generated by the company
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub old_token_account: UncheckedAccount<'info>,

    // token account of the user that will be generated by the user and encrypted with the private key
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub new_token_account: UncheckedAccount<'info>,

    pub token_program: Program<'info, token::Token>,
}
