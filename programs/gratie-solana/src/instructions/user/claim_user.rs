// claim the bucket by generating a new private key and encrypting it with the company name, user email and user password (plaintext)

use anchor_lang::{
    prelude::*,
    solana_program::{program::invoke, system_instruction},
};
use anchor_spl::token::{self, Token};

use crate::{
    error::MyError,
    instructions::util::transfer_all_tokens,
    state::{user::User, user_rewards_bucket::UserRewardsBucket},
};

pub fn claim_user_handler(
    ctx: Context<ClaimUser>,
    //TODO: maybe remove this from args
    new_user_encrypted_private_key: String,
) -> Result<()> {
    if ctx.accounts.old_token_account.key() != ctx.accounts.user_rewards_bucket.token_account.key()
    {
        return Err(MyError::InvalidOldTokenAccount.into());
    }

    if ctx.accounts.user.claimed {
        return Err(MyError::UserAlreadyClaimed.into());
    }

    // TODO: maybe check this
    // if ctx.accounts.new_token_account.key() != new_user_public_key {
    //     return Err(MyError::InvalidNewTokenAccount.into());
    // }

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.old_token_account.to_account_info(),
        to: ctx.accounts.new_token_account.to_account_info(),
        authority: ctx.accounts.claimer.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    token::transfer(cpi_ctx, ctx.accounts.user_rewards_bucket.balance)?;

    ctx.accounts.user.encrypted_private_key = Some(new_user_encrypted_private_key);

    ctx.accounts.user.owner = ctx.accounts.user_account.key();
    ctx.accounts.user.user_password_encryption_algorithm = None;
    ctx.accounts.user.user_password_salt = None;

    ctx.accounts.user_rewards_bucket.token_account = ctx.accounts.new_token_account.key();
    ctx.accounts.user.claimed = true;

    transfer_all_tokens(
        ctx.accounts.claimer.to_account_info(),
        ctx.accounts.user_account.to_account_info(),
    )?;

    Ok(())
}

// TODO: implement some checks for token account
#[derive(Accounts)]
pub struct ClaimUser<'info> {
    #[account(mut, address = user.owner)]
    pub claimer: Signer<'info>,

    #[account(mut)]
    pub user: Account<'info, User>,

    #[account(mut, seeds = [b"user_rewards_bucket", user.key().as_ref()], bump = user_rewards_bucket.bump)]
    pub user_rewards_bucket: Account<'info, UserRewardsBucket>,

    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub user_account: AccountInfo<'info>,

    // token account of the user that was generated by the company
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub old_token_account: UncheckedAccount<'info>,

    // token account of the user that will be generated by the user and encrypted with the private key
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub new_token_account: UncheckedAccount<'info>,

    pub token_program: Program<'info, Token>,

    pub system_program: Program<'info, System>,
}
